#include <Catmul.compute>

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
static const float PI = 3.14159265f;

RWStructuredBuffer<float3> vertecies;
RWStructuredBuffer<int> triangles;
StructuredBuffer<float3> positions;
StructuredBuffer<float> vigors;
RWStructuredBuffer<float> debug;

int height;
int width;
int numOfPositionsMax;

float heightDivider;
float widthDivider;

float3 crossVec;

bool IsZeroFloat3(float3 value)
{
    return (value.x == -1000 && value.y == -1000 && value.z == -1000);
}

float4 qmul(float4 q1, float4 q2)
{
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
        );
}

P CalculatePoitns(int pointIdx)
{
    float3 p1 = positions[pointIdx];
    float3 p2 = positions[pointIdx + 1];
    float3 p0;
    if (pointIdx == 0 || IsZeroFloat3(positions[max(0, pointIdx - 1)]))
    {
        p0 = p1 + p1 - p2;
    }
    else
    {
        p0 = positions[pointIdx - 1];
    }
    float3 p3;
    //if (pointIdx + 2 >= numOfPositions)
    if (IsZeroFloat3(positions[pointIdx + 2]))
    {
        p3 = p2 + p2 - p1;
    }
    else
    {
        p3 = positions[pointIdx + 2];
    }

    P points;
    points.x = p0;
    points.y = p1;
    points.z = p2;
    points.w = p3;
    return points;
}

void GenerateMeshRing(P points, int heightIdx, float radius1, float radius2, int insertIdx)
{
    float t = (float) heightIdx * heightDivider;
    float3 centerPoint = GetPoint(points.x, points.y, points.z, points.w, t, .5);
    float3 dir = GetDerivative(points.x, points.y, points.z, points.w, t, .5);

    float anglee = 0;
    float angleIncements = 360 * widthDivider;
    
    float3 w = cross(crossVec, dir);
    float radius = lerp(radius1, radius2, t);
    w = normalize(w) * radius;
    
    for (int i = 0; i < width; i++)
    {
        float angle = anglee * PI / 180.0f;
        float sn = sin(angle * 0.5);
        float cs = cos(angle * 0.5);
        float4 rot = float4(dir * sn, cs);
        float4 rinv = rot * float4(-1, -1, -1, -1);

        // w = qmul(rinv, qmul(rot, float4(w, 0))).xyz;
        float3 wtmp = qmul(rinv, qmul(rot, float4(w, 0))).xyz;
        //vertecies[insertIdx + i] = float3(points.y.y, points.z.y, heightIdx);
        vertecies[insertIdx + i] = centerPoint + wtmp;
        anglee += angleIncements;
    }
}

bool isMeshNeeded(int pointIdx, int currentHeigt)
{
    if (IsZeroFloat3(positions[pointIdx]))
        return false;
    if (pointIdx + 1 <= numOfPositionsMax);
    {
        if (IsZeroFloat3(positions[pointIdx + 1]))
            return false;
    }
    if(pointIdx - 1 >= 0)
    if(IsZeroFloat3(positions[pointIdx - 1]))
        return false;
    return true;
    // the -2 at the end is related with the -3 in the check before triangles
    // most of these checks are only nessesay cause of the placement but may can be removed later on when placement
    // is improved
}

int2 GetAlreadyAppliedVertexNumebr(int idx, int currentHeight)
{
    int alreadyApplied = 0;
    int pastEnds = 0;
    for (int i = 0; i < idx; i++)
    {
        if (IsZeroFloat3(positions[i]))
        {
            pastEnds++;
        }
        for (int j = 0; j < height; j++)
        {
            if (isMeshNeeded(i, j))
            {
                alreadyApplied++;
            }
        }
    }
    for (int i = 0; i < currentHeight; i++)
    {
        if (isMeshNeeded(idx, i))
        {
            alreadyApplied++;
        }
    }
    int normalAppliedVerts = alreadyApplied * width;
    return int2(normalAppliedVerts + pastEnds, (normalAppliedVerts - width) * 6 + pastEnds * width * 3);
}

void AddTriangles(int insertIdx, int vertIdx)
{
    int _vertIdx = vertIdx;
    for (int i = 0; i < width - 1; i++)
    {
        int ul = _vertIdx;
        int ur = _vertIdx + 1;
        int ll = _vertIdx - width;
        int lr = _vertIdx - width + 1;
        _vertIdx++;
        triangles[insertIdx] = ur;
        triangles[insertIdx + 1] = ul;
        triangles[insertIdx + 2] = ll;
        triangles[insertIdx + 3] = ur;
        triangles[insertIdx + 4] = ll;
        triangles[insertIdx + 5] = lr;
        
        insertIdx += 6;
    }
    
    debug[0] = vertIdx;
    int ul = _vertIdx;
    int ur = vertIdx;
    int ll = _vertIdx - width;
    int lr = vertIdx - width;
    
    triangles[insertIdx] = ur;
    triangles[insertIdx + 1] = ul;
    triangles[insertIdx + 2] = ll;
    triangles[insertIdx + 3] = ur;
    triangles[insertIdx + 4] = ll;
    triangles[insertIdx + 5] = lr;
}

void AddTopTriangles(int insertIdx, int vertIdx)
{
    int _vertIdx = vertIdx;
    for (int i = 0; i < width - 1; i++)
    {
        int u = vertIdx;
        int ll = _vertIdx - width;
        int lr = _vertIdx - width + 1;
        _vertIdx++;
        
        triangles[insertIdx] = u;
        triangles[insertIdx + 1] = ll;
        triangles[insertIdx + 2] = lr;
        insertIdx += 3;
    }
    int u = vertIdx;
    int ll = _vertIdx - width;
    int lr = vertIdx - width;
    
    triangles[insertIdx] = u;
    triangles[insertIdx + 1] = lr;
    triangles[insertIdx + 2] = ll;
}

[numthreads(32, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int pointIdx = floor(id.x * heightDivider);
    if(pointIdx >= numOfPositionsMax)
    {
        return;
    }
    int currentHeight = id.x % height;
    debug[id.x] = pointIdx;
    if (!isMeshNeeded(pointIdx, currentHeight))
    {
        return;
    }
    
    float radius1 = .2 * vigors[pointIdx];
    float radius2 = .2 * vigors[pointIdx + 1];
    int2 valuesBefore = GetAlreadyAppliedVertexNumebr(pointIdx, currentHeight);
    int verteciesBefore = valuesBefore[0];
    int trianglesBefore = valuesBefore[1];
    
    P points = CalculatePoitns(pointIdx);
    GenerateMeshRing(points, currentHeight, radius1, radius2, verteciesBefore);
    
    if (currentHeight == 0)
    {
        if (pointIdx == 0)
        {
            return;
        }
        
        else if (pointIdx - 2 >= 0)
        {
            if (IsZeroFloat3(positions[pointIdx - 2]))
            {
                return;
            }
        }
        //else if (IsZeroFloat3(positions[pointIdx - 3]) && pointIdx > 1)
        //    return;
    }
    
    AddTriangles(trianglesBefore, verteciesBefore);
    if (IsZeroFloat3(positions[pointIdx + 2]) && height == currentHeight + 1)
    {
        vertecies[verteciesBefore + width] = positions[pointIdx + 1];
        AddTopTriangles(trianglesBefore + width * 6, verteciesBefore + width);
    }
}


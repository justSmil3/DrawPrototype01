#include <Catmul.compute>

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> vertecies;
RWStructuredBuffer<int> triangles;
StructuredBuffer<float3> positions;
StructuredBuffer<float> vigors;
RWStructuredBuffer<float> debug;

int numVerts;
int numOfPositionsMax;
int height;
int width;
int numEnds;

float heightDivider;
float widthDivider;

float3 crossVec;

static const float PI = 3.14159265f;

bool IsZeroFloat3(float3 value)
{
    return (value.x == -1000 && value.y == -1000 && value.z == -1000);
}

float4 qmul(float4 q1, float4 q2)
{
    return float4(
        q2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),
        q1.w * q2.w - dot(q1.xyz, q2.xyz)
        );
}

int2 RecalculatePointIdx(int idx)
{
    int i = 1;
    int leftOut = 0;
    while (i <= idx)
    {
        if (IsZeroFloat3(positions[i + 1]))
        {
            if (idx < numOfPositionsMax - 2)
            {
                idx += 2;
                leftOut++;
            }
        }
        i++;
    }
    return int2(idx, leftOut);
}

P CalculatePoitns(int pointIdx)
{
    float3 p1 = positions[pointIdx];
    float3 p2 = positions[pointIdx + 1];
    float3 p0;
    if (pointIdx == 0 || IsZeroFloat3(positions[max(0, pointIdx - 1)]))
    {
        p0 = p1 + p1 - p2;
    }
    else
    {
        p0 = positions[pointIdx - 1];
    }
    float3 p3;
    //if (pointIdx + 2 >= numOfPositions)
    if (IsZeroFloat3(positions[pointIdx + 2]))
    {
        p3 = p2 + p2 - p1;
    }
    else
    {
        p3 = positions[pointIdx + 2];
    }

    P points;
    points.x = p0;
    points.y = p1;
    points.z = p2;
    points.w = p3;
    return points;
}

void GenerateMeshRing(P points, int heightIdx, float radius1, float radius2, int insertIdx)
{
    float t = (float) heightIdx * heightDivider;
    float3 centerPoint = GetPoint(points.x, points.y, points.z, points.w, t, .5);
    float3 dir = GetDerivative(points.x, points.y, points.z, points.w, t, .5);
    
    float anglee = 0;
    float angleIncements = 360 * widthDivider;
    
    float3 w = cross(crossVec, dir);
    float radius = lerp(radius1, radius2, t);
    w = normalize(w) * radius;
    
    for (int i = 0; i < width; i++)
    {
        float angle = anglee * PI / 180.0f;
        float sn = sin(angle * 0.5);
        float cs = cos(angle * 0.5);
        float4 rot = float4(dir * sn, cs);
        float4 rinv = rot * float4(-1, -1, -1, -1);

        // w = qmul(rinv, qmul(rot, float4(w, 0))).xyz;
        float3 wtmp = qmul(rinv, qmul(rot, float4(w, 0))).xyz;
        //vertecies[insertIdx + i] = float3(points.y.y, points.z.y, heightIdx);
        vertecies[insertIdx + i] = centerPoint + wtmp;
        anglee += angleIncements;
    }

}

int GetNumOfLeftOutRows(int pointIdx)
{
    int leftOutRows = 1;
    for (int i = 1; i < pointIdx; i++)
    {
        if (IsZeroFloat3(positions[pointIdx]))
        {
            leftOutRows += 2;
        }
    }
    return leftOutRows;
}

void AddTriangles(int vIdx, int leftOut)
{
    int insertIdx = (vIdx - width) * 6 +(leftOut * width * 3);
    int vertCountBelow = vIdx + leftOut;
    
    for (int i = 0; i < width; i++)
    {
        int ul = vIdx + leftOut;
        int ur = ((vIdx + 1) % width) + vertCountBelow;
        int ll = vIdx - width + leftOut;
        int lr = ((vIdx - width + 1) % width) + vertCountBelow - width;
        vIdx += 1;
        
        triangles[insertIdx] = ur;
        triangles[insertIdx + 1] = ul;
        triangles[insertIdx + 2] = ll;
        triangles[insertIdx + 3] = ur;
        triangles[insertIdx + 4] = ll;
        triangles[insertIdx + 5] = lr;

        insertIdx += 6;
    }
}

void AddTopTriangles(int vIdx, int leftOut) 
{
    int insertIdx = vIdx * 6 + (leftOut * width * 3);
    int vertCountBelow = vIdx;

    for (int i = 0; i < width; i++)
    {
        int u = vertCountBelow  + width + leftOut;
        int ll = vIdx + leftOut;
        int lr = ((vIdx + 1) % width) + vertCountBelow + leftOut;
        vIdx += 1;

         triangles[insertIdx] = u;
         triangles[insertIdx + 1] = lr;
         triangles[insertIdx + 2] = ll;

        insertIdx += 3;
    }
}

[numthreads(32, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

    if (id.x * width + numEnds >= numVerts)
        return;

    int pointIdx;
    int heightIdx;

    pointIdx = (int)(id.x * heightDivider);
    heightIdx = id.x % height;
    int leftOut;
    int2 tmp = RecalculatePointIdx(pointIdx);
    
    pointIdx = tmp[0];
    leftOut = tmp[1];
    int vertexInsertIdx = id.x * width +leftOut;
    int triInsertIdx = (id.x) * width;


    float radius1 = .2 * vigors[pointIdx];
    float radius2 = .2 * vigors[pointIdx + 1];
    P points = CalculatePoitns(pointIdx);
    GenerateMeshRing(points, heightIdx, radius1, radius2, vertexInsertIdx);
    
    if(heightIdx == 0)
    {
        if(pointIdx == 0)
            return;
        else if (IsZeroFloat3(positions[pointIdx - 1]) && pointIdx > 1)
            return;
    }
    
    AddTriangles(triInsertIdx, leftOut);
    debug[pointIdx] = 5;

    if (IsZeroFloat3(positions[pointIdx + 2]) && height == heightIdx + 1)
    {
        vertecies[vertexInsertIdx + width] = positions[pointIdx + 1];
        AddTopTriangles(triInsertIdx, leftOut);
    }
}

